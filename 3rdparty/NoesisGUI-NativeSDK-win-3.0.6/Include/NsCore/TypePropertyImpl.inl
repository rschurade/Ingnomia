////////////////////////////////////////////////////////////////////////////////////////////////////
// NoesisGUI - http://www.noesisengine.com
// Copyright (c) 2013 Noesis Technologies S.L. All Rights Reserved.
////////////////////////////////////////////////////////////////////////////////////////////////////


#include <NsCore/TypeOf.h>
#include <NsCore/TypePropertyUtil.h>


namespace Noesis
{

////////////////////////////////////////////////////////////////////////////////////////////////////
template<class T>
TypePropertyOffset<T>::TypePropertyOffset(Symbol name, uint32_t offset):
    TypeProperty(name, TypeOf<TT>()), mOffset(offset)
{
}

////////////////////////////////////////////////////////////////////////////////////////////////////
template<class T>
void* TypePropertyOffset<T>::GetContent(void* ptr) const
{
    return (uint8_t*)ptr + mOffset;
}

////////////////////////////////////////////////////////////////////////////////////////////////////
template<class T>
const void* TypePropertyOffset<T>::GetContent(const void* ptr) const
{
    return (const uint8_t*)ptr + mOffset;
}

////////////////////////////////////////////////////////////////////////////////////////////////////
template<class T>
Ptr<BaseComponent> TypePropertyOffset<T>::GetComponent(const void* ptr) const
{
    return Noesis::GetComponent<TT>(this, ptr);
}

////////////////////////////////////////////////////////////////////////////////////////////////////
template<class T>
void TypePropertyOffset<T>::SetComponent(void* ptr, BaseComponent* value) const
{
    Noesis::SetComponent<TT>(this, ptr, value);
}

////////////////////////////////////////////////////////////////////////////////////////////////////
template<class T>
const void* TypePropertyOffset<T>::InternalGet(const void* ptr) const
{
    return (const uint8_t*)ptr + mOffset;
}

////////////////////////////////////////////////////////////////////////////////////////////////////
template<class T>
void TypePropertyOffset<T>::InternalGet(const void* ptr, void* storage) const
{
    TT* storageT = static_cast<TT*>(storage);
    *storageT = *(TT*)((const uint8_t*)ptr + mOffset);
}

////////////////////////////////////////////////////////////////////////////////////////////////////
template<class T>
void TypePropertyOffset<T>::InternalSet(void* ptr, const void* value) const
{
    *(TT*)((uint8_t*)ptr + mOffset) = *static_cast<const TT*>(value);
}

////////////////////////////////////////////////////////////////////////////////////////////////////
template<class T>
bool TypePropertyOffset<T>::InternalIsReadOnly() const
{
    return IsConst<T>::Result;
}

////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////
template<class T, uint32_t N>
TypePropertyArray<T,N>::TypePropertyArray(Symbol name, uint32_t offset):
    TypeProperty(name, TypeOf<T[N]>()), mOffset(offset)
{
}

////////////////////////////////////////////////////////////////////////////////////////////////////
template<class T, uint32_t N>
void* TypePropertyArray<T,N>::GetContent(void* ptr) const
{
    return (uint8_t*)ptr + mOffset;
}

////////////////////////////////////////////////////////////////////////////////////////////////////
template<class T, uint32_t N>
const void* TypePropertyArray<T,N>::GetContent(const void* ptr) const
{
    return (const uint8_t*)ptr + mOffset;
}

////////////////////////////////////////////////////////////////////////////////////////////////////
template<class T, uint32_t N>
Ptr<BaseComponent> TypePropertyArray<T,N>::GetComponent(const void*) const
{
    // Array properties can't be boxed
    NS_ASSERT_UNREACHABLE;
}

////////////////////////////////////////////////////////////////////////////////////////////////////
template<class T, uint32_t N>
void TypePropertyArray<T,N>::SetComponent(void*, BaseComponent*) const
{
    // Array properties can't be boxed
    NS_ASSERT_UNREACHABLE;
}

////////////////////////////////////////////////////////////////////////////////////////////////////
template<class T, uint32_t N>
const void* TypePropertyArray<T,N>::InternalGet(const void* ptr) const
{
    return (const uint8_t*)ptr + mOffset;
}

////////////////////////////////////////////////////////////////////////////////////////////////////
template<class T, uint32_t N>
void TypePropertyArray<T,N>::InternalGet(const void*, void*) const
{
    // Can't get array properties by copy
    NS_ASSERT_UNREACHABLE;
}

////////////////////////////////////////////////////////////////////////////////////////////////////
template<class T, uint32_t N>
void TypePropertyArray<T,N>::InternalSet(void*, const void*) const
{
    // Can't set an array property
    NS_ASSERT_UNREACHABLE;
}

////////////////////////////////////////////////////////////////////////////////////////////////////
template<class T, uint32_t N>
bool TypePropertyArray<T,N>::InternalIsReadOnly() const
{
    return true;
}

////////////////////////////////////////////////////////////////////////////////////////////////////
template<class C, class T>
const void* TypePropertyFunction<C,T>::ByRef::GetRef(GetterFn getter, const void* ptr)
{
    return &(static_cast<const C*>(ptr)->*getter)();
}

////////////////////////////////////////////////////////////////////////////////////////////////////
template<class C, class T>
void TypePropertyFunction<C,T>::ByRef::GetCopy(GetterFn, const void*, void*)
{
    // Should return value by reference
    NS_ASSERT_UNREACHABLE;
}

////////////////////////////////////////////////////////////////////////////////////////////////////
template<class C, class T>
const void* TypePropertyFunction<C,T>::ByCopy::GetRef(GetterFn, const void*)
{
    // Can't get a reference to an unnamed value
    NS_ASSERT_UNREACHABLE;
}

////////////////////////////////////////////////////////////////////////////////////////////////////
template<class C, class T>
void TypePropertyFunction<C,T>::ByCopy::GetCopy(GetterFn getter, const void* ptr, void* storage)
{
    // We need to split this in two lines or GCC 7 - 8 - 9 will ignore the assignment (bug?)
    T r = (static_cast<const C*>(ptr)->*getter)();
    *(static_cast<T*>(storage)) = r;
}

////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////
template<class C, class T>
TypePropertyFunction<C,T>::TypePropertyFunction(Symbol name, GetterFn getter, SetterFn setter):
    TypeProperty(name, TypeOf<T>()), mGetter(getter), mSetter(setter)
{
    NS_ASSERT(mGetter);
}

////////////////////////////////////////////////////////////////////////////////////////////////////
template<class C, class T>
void* TypePropertyFunction<C,T>::GetContent(void* ptr) const
{
    return const_cast<void*>(Helper::GetRef(mGetter, ptr));
}

////////////////////////////////////////////////////////////////////////////////////////////////////
template<class C, class T>
const void* TypePropertyFunction<C,T>::GetContent(const void* ptr) const
{
    return Helper::GetRef(mGetter, ptr);
}

////////////////////////////////////////////////////////////////////////////////////////////////////
template<class C, class T>
Ptr<BaseComponent> TypePropertyFunction<C,T>::GetComponent(const void* ptr) const
{
    return Noesis::GetComponent<T>(this, ptr);
}

////////////////////////////////////////////////////////////////////////////////////////////////////
template<class C, class T>
void TypePropertyFunction<C,T>::SetComponent(void* ptr, BaseComponent* value) const
{
    Noesis::SetComponent<T>(this, ptr, value);
}

////////////////////////////////////////////////////////////////////////////////////////////////////
template<class C, class T>
const void* TypePropertyFunction<C,T>::InternalGet(const void* ptr) const
{
    return Helper::GetRef(mGetter, ptr);
}

////////////////////////////////////////////////////////////////////////////////////////////////////
template<class C, class T>
void TypePropertyFunction<C,T>::InternalGet(const void* ptr, void* storage) const
{
    Helper::GetCopy(mGetter, ptr, storage);
}

////////////////////////////////////////////////////////////////////////////////////////////////////
template<class C, class T>
void TypePropertyFunction<C,T>::InternalSet(void* ptr, const void* value) const
{
    NS_ASSERT(mSetter);
    (static_cast<C*>(ptr)->*mSetter)(*static_cast<const T*>(value));
}

////////////////////////////////////////////////////////////////////////////////////////////////////
template<class C, class T>
bool TypePropertyFunction<C,T>::InternalIsReadOnly() const
{
    return mSetter == 0;
}

////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////
TypePropertyOffsetEvent::TypePropertyOffsetEvent(Symbol name, uint32_t offset):
    TypeProperty(name, nullptr), mOffset(offset)
{
}

////////////////////////////////////////////////////////////////////////////////////////////////////
void* TypePropertyOffsetEvent::GetContent(void* ptr) const
{
    return (uint8_t*)ptr + mOffset;
}

////////////////////////////////////////////////////////////////////////////////////////////////////
const void* TypePropertyOffsetEvent::GetContent(const void* ptr) const
{
    return (const uint8_t*)ptr + mOffset;
}

////////////////////////////////////////////////////////////////////////////////////////////////////
Ptr<BaseComponent> TypePropertyOffsetEvent::GetComponent(const void*) const
{
    NS_ASSERT_UNREACHABLE;
}

////////////////////////////////////////////////////////////////////////////////////////////////////
void TypePropertyOffsetEvent::SetComponent(void*, BaseComponent*) const
{
    NS_ASSERT_UNREACHABLE;
}

////////////////////////////////////////////////////////////////////////////////////////////////////
const void* TypePropertyOffsetEvent::InternalGet(const void* ptr) const
{
    return (const uint8_t*)ptr + mOffset;
}

////////////////////////////////////////////////////////////////////////////////////////////////////
void TypePropertyOffsetEvent::InternalGet(const void*, void*) const
{
    NS_ASSERT_UNREACHABLE;
}

////////////////////////////////////////////////////////////////////////////////////////////////////
void TypePropertyOffsetEvent::InternalSet(void*, const void*) const
{
    NS_ASSERT_UNREACHABLE;
}

////////////////////////////////////////////////////////////////////////////////////////////////////
bool TypePropertyOffsetEvent::InternalIsReadOnly() const
{
    return true;
}

////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////
template<class C>
TypePropertyFunctionEvent<C>::TypePropertyFunctionEvent(Symbol name, GetterFn getter):
    TypeProperty(name, nullptr), mGetter(getter)
{
}

////////////////////////////////////////////////////////////////////////////////////////////////////
template<class C>
void* TypePropertyFunctionEvent<C>::GetContent(void* ptr) const
{
    return ((C*)(ptr)->*mGetter)();
}

////////////////////////////////////////////////////////////////////////////////////////////////////
template<class C>
const void* TypePropertyFunctionEvent<C>::GetContent(const void* ptr) const
{
    return ((C*)(ptr)->*mGetter)();
}

////////////////////////////////////////////////////////////////////////////////////////////////////
template<class C>
Ptr<BaseComponent> TypePropertyFunctionEvent<C>::GetComponent(const void*) const
{
    NS_ASSERT_UNREACHABLE;
}

////////////////////////////////////////////////////////////////////////////////////////////////////
template<class C>
void TypePropertyFunctionEvent<C>::SetComponent(void*, BaseComponent*) const
{
    NS_ASSERT_UNREACHABLE;
}

////////////////////////////////////////////////////////////////////////////////////////////////////
template<class C>
const void* TypePropertyFunctionEvent<C>::InternalGet(const void* ptr) const
{
    return ((C*)(ptr)->*mGetter)();
}

////////////////////////////////////////////////////////////////////////////////////////////////////
template<class C>
void TypePropertyFunctionEvent<C>::InternalGet(const void*, void*) const
{
    NS_ASSERT_UNREACHABLE;
}

////////////////////////////////////////////////////////////////////////////////////////////////////
template<class C>
void TypePropertyFunctionEvent<C>::InternalSet(void*, const void*) const
{
    NS_ASSERT_UNREACHABLE;
}

////////////////////////////////////////////////////////////////////////////////////////////////////
template<class C>
bool TypePropertyFunctionEvent<C>::InternalIsReadOnly() const
{
    return true;
}

}
